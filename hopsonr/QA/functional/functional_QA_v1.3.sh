#version history
#v1.3 - at Kosha's request, added spikerate. Also made column names task-specific for better redcap integration.

#useage
function Usage {
	cat <<USAGE
Usage:
  -a:  full path to Audit file, generated by an xnat_audit.py. Required.
  -s:  Sequence name, as column is named in audit file. Required.
  -f:  File path within subject dir, as regular expression. Required.
  -p:  Protocol name as on monstrum. Required.
  -x:  Protocol name as in xnat. Required.
  -o:  Output path to csv. Required.
  -m:  Mask for checking coverage. Required.
  -b:  Behavioral measure for QA,minimum value. Can be used multiple times. Eg. "-b allcorrect,54 -b targetcorrect,30"
  -c:  Path from subject level directory to score file. Required if using behavioral measures. Eg. "-c \"scores/iDemo2.10/*_test_output_scores.csv\""
  -w:  overWrite previously completed QA. 0 = no, 1 = yes. Defalut = 0.
  -e:  Email address for error reporting.
  -r:  Redcap protocol name for automatic uploading.
  -t:  Testing mode.
  -v:  Values to use for meanrelrms, maxrelrms, and tSNR cut offs, comma separated. Default = 0.5,6,30

USAGE
	exit 1
}

###set defaults
overwrite=0
meanrelrms_cutoff=0.5
maxrelrms_cutoff=6
tsnr_cutoff=30

###check for args
[ $# -lt 1 ] && Usage

# reading command line arguments
while getopts ":a:p:f:s:ho:m:e:w:tx:c:b:v:" OPT
	do
	case $OPT in
		h) #help
		Usage >&2
		exit 0
		;;
		a) #audit file
		audit_file=$OPTARG
		;;
		s) #column name
		sequence_name=$OPTARG
		;;
		f) #path to file
		file_path=$OPTARG
		;;
		p) #protocol name as on monstrum
		protocol=$OPTARG
		;;
		o) #path to output
		out_path=$OPTARG
		;;
		x) #path to output
		xnat_name=$OPTARG
		;;
		m) #path to mask for coverage check
		mask_path=$OPTARG
		;;
		w) #should old data be overwritten?
		overwrite=$OPTARG
		;;
		e) #email address for error reporting
		email=$OPTARG
		;;
		b) #behavioral measures with minimums
		behavioral_args=`echo $behavioral_args $OPTARG`
		;;
		r) #name of redcap project for automated uploading
		redcap_name=$OPTARG
		;;
		c) #name of folder within scores that contains sequence specific data
		behave_file_name=$OPTARG
		;;
		v) #values to use for excluding based on tsnr and motion
		meanrelrms_cutoff=`echo $OPTARG | cut -d "," -f 1`
		maxrelrms_cutoff=`echo $OPTARG | cut -d "," -f 2`
		tsnr_cutoff=`echo $OPTARG | cut -d "," -f 3`
		;;
		t) #testing mode
		testing=1
		;;
		\?) # getopts issues an error message
		Usage >&2
		exit 1
		;;
	esac
done

#set variables automatically for testing purposes
if [ ! -z $testing ];then
	#audit_file=/import/monstrum/eons2_xnat/scripts/xnat_stats/n404_xnat_audit.csv
	audit_file=/import/monstrum/eons_xnat/redcap/imaging_variables/n1601_eons_xnat_audit_7_1_14.csv
	sequence_name=perf
	#protocol=eons2_xnat
	protocol=eons_xnat
	file_path="*_ep2d_se_pcasl_PHC_1200ms/quant_[dn][io][c_][od][_i][bc][eo]*/reg_std_ants/cbf_map_*_2mm.nii.gz"
	out_path=/import/monstrum/eons_xnat/redcap/imaging_variables/n1601_asl_automated_QA_4_9_15.csv
	#out_path=/import/monstrum/eons2_xnat/scripts/ASL/QA/automated_qa.csv
	mask_path=/import/monstrum/eons_xnat/progs/ASL/reg_check_n931_mask_brain.nii.gz
	email=hopsonr@bbl.med.upenn.edu
	overwrite=0
fi

###set up error path
out_dir=`dirname $out_path`
error_path=$out_dir/error_log.txt
[ -e $error_path ] && rm -f $error_path

echo "Audit file is: "$audit_file
echo "Sequence name is: "$sequence_name
echo "Output file is: "$out_path

###check arguments
errors=""
[ ! -e "$audit_file" ] && errors=`echo $errors "Missing audit file."`
[ ! -d "/import/monstrum/$protocol" ] && errors=`echo $errors "Missing study directory."`
[ ! -e "$mask_path" ] && errors=`echo $errors "Missing mask for coverage check."`
[ -z "$sequence_name" ] && errors=`echo $errors "No sequence name specified."`
[ "X$behavioral_args" != "X" ] && [ "X$behave_file_name" == "X" ] && errors=`echo $errors "No score file for behavioral measures specified."`

#check that all behavioral measures have minimums specified, and make header
for behavioral_measure in $behavioral_args
do
	measure_name=`echo $behavioral_measure | cut -d "," -f 1`
	measure_min=`echo $behavioral_measure | cut -d "," -f 2`
	[ -z "$measure_min" ] && errors=`echo $errors "No minimum for $measure_name."`
	measure_head=`echo $measure_head,$measure_name'_behave',$measure_name'_min'`
	measure_filler=`echo $measure_filler,,`
done
measure_head=`echo $measure_head | sed s/^,//`
measure_filler=`echo $measure_filler | sed s/^,//`

###check dependencies
[ ! -d "$FSLDIR" ] && errors=`echo $errors "Missing FSLDIR."`
[ ! -e "$FSLDIR/data/standard/tissuepriors/avg152T1_gray_bin.nii.gz" ] && errors=`echo $errors "Missing grey matter mask."`
[ ! -e "/import/speedy/scripts/hopsonr/QA/check_coverage_QA_v3.sh" ] && errors=`echo $errors "Missing coverage script."`
[ ! -e "/import/speedy/scripts/hopsonr/QA/check_registration_QA_v2.sh" ] && errors=`echo $errors "Missing registration script."`
[ ! -e "/import/speedy/scripts/hopsonr/QA/get_xnat_epi10.py" ] && errors=`echo $errors "Missing qa epi10 download script."`

###find fields necessary from audit file
if [ -e "$audit_file" ] && [ ! -z $sequence_name ]; then
	field=1
	for column_name in `head -1 $audit_file | tr ',' ' '`
	do
		[ $column_name == $sequence_name ] && sequence_field=$field
		[ $column_name == 'subject' ] && scanid_field=$field
		[ $column_name == 'bblid' ] && bblid_field=$field	
		field=$((field+1))
	done
	###check that needed fields found
	[ -z $sequence_field ] || [ -z $bblid_field ] || [ -z $scanid_field ] && errors=`echo $errors "Sequence, bblid, or scanid not found in audit file"`
fi

###if any errors, exit
if [ ! -z "$errors" ];then 
	echo $errors 
	[ "$error_path" != "/error_log.txt" ] && echo $errors > $error_path 
	exit 2
fi

###get QA epi 10 data
run_qa_epi10 () {
	day=`date +%m_%d_%y`
	last_epi10_file=`ls $out_dir/qa_epi10_*.csv 2> /dev/null`
	lastrun=`basename $last_epi10_file 2> /dev/null | cut -d "." -f 1 | cut -d "_" -f 3,4,5`
	echo "today is: "$day
	echo "qa epi10 audit last run on: "$lastrun

	[ "X$lastrun" == "X" ] && lastrun="none"
	if [ $lastrun != $day ];then
		echo "removing old file"
		old_test=`ls $out_dir/qa_epi10_*.csv 2> /dev/null`
		[ "X$old_test" != "X" ] && rm -f $out_dir/qa_epi10_*.csv
		echo "running get epi10"
		echo "/import/speedy/scripts/hopsonr/QA/get_xnat_epi10.py -configfile ~/.xnat.cfg -project $xnat_name > "$out_dir/qa_epi10_"$day".csv
		/import/speedy/scripts/hopsonr/QA/get_xnat_epi10.py -configfile ~/.xnat.cfg -project $xnat_name > "$out_dir/qa_epi10_"$day".csv"
	fi
	epi10_file="$out_dir/qa_epi10_"$day".csv"
	echo "epi10_file is "$epi10_file
}
run_qa_epi10

###find necessary fields in qa_epi10
if [ -e "$epi10_file" ]; then
	field=1
	for column_name in `head -1 $epi10_file | tr ',' ' '`
	do
		[ $column_name == 'meanrelrms' ] && meanrelrms_field=$field
		[ $column_name == 'tsnr2' ] && tsnr2_field=$field
		[ $column_name == 'maxrelrms' ] && maxrelrms_field=$field	
		[ $column_name == 'spikerate2' ] && spikerate_field=$field
		field=$((field+1))
	done
	###check that needed fields found
	[ -z $meanrelrms_field ] || [ -z $tsnr2_field ] || [ -z $maxrelrms_field ] && errors=`echo $errors "Sequence, bblid, or scanid not found in audit file"`
fi

###create header line, including name of sequence
header_line=`echo bblid,scanid,user,hostname,version,no_data_collected,missing_processed_data_exclude,meanrel,maxrel,tsnr,spikerate,zeros_in_mask,voxels_out_of_mask,fslcc,$measure_head`
for column in `echo $header_line | tr "," " "`;do
new_header_line=`echo $new_header_line,$sequence_name"_"$column`
done
new_header_line=`echo $new_header_line | sed 's/^,//g'`

###initiate output file
[ $overwrite == 1 ] && echo $new_header_line > $out_path
echo $new_header_line


###main loop - do for each subject in the audit
for line in `cat $audit_file | sed -n 2,'$'p`
#for line in `cat $audit_file | grep 8723,` #for testing
do
	#echo $line
	###set variables from audit file
	scanid=`echo $line | cut -d "," -f $scanid_field | sed s/^0*//`
	bblid=`echo $line | cut -d "," -f $bblid_field | sed s/^0*//`
	has_sequence=`echo $line | cut -d "," -f $sequence_field`
	found_data=0

	###set up subject errors
	subject_errors=$bblid,$scanid

	###if not overwriting, skip if already in QA output, iff it previously ran error free
	if [ $overwrite == 0 ];then
		previous_QA=`grep -q ",$scanid," $out_path`
		previous_error=`echo $previous_QA | cut -d "," -f 7`
		if [ "X$previous_error" == "X1" ];then
			echo $scanid found in $out_path with error. Will rerun.
		else
			echo $scanid found in $out_path
			continue
		fi
	fi

	if [ $has_sequence == 0 ]
	then
		echo $bblid,$scanid,$USER,$HOSTNAME,$0,1,,,,,,,,$measure_filler
		echo $bblid,$scanid,$USER,$HOSTNAME,$0,1,,,,,,,,$measure_filler >> $out_path
		continue
	fi

	###get qa_epi10 line
	qa_epi10=`grep ',00'$scanid,'.*'$sequence_name "$out_dir/qa_epi10_"$day".csv"`
	[ -z $qa_epi10 ] && qa_epi10lines=0 || qa_epi10lines=`echo $qa_epi10 | wc -l`
	#echo $qa_epi10
	#echo $qa_epi10lines
	if [ $qa_epi10lines != 1 ] || [ "X$qa_epi10" == "X" ];then
		subject_errors=`echo $subject_errors,"$qa_epi10lines lines found in qa_epi10"`
		echo $subject_errors >> $error_path
		continue
	fi

	###check motion variables
	#get from qa_epi10
	maxrel=`echo $qa_epi10 | cut -d "," -f $maxrelrms_field`
	meanrel=`echo $qa_epi10 | cut -d "," -f $meanrelrms_field`

	###get tsnr
	meantsnr=`echo $qa_epi10 | cut -d "," -f $tsnr2_field`

	###check behavioral data
	behave=`ls -d /import/monstrum/$protocol/subjects/$bblid"_"$scanid/$behave_file_name 2> /dev/null`
	behave_count=`echo $behave | wc -w`
	if [ $behave_count != 1 ];then
	[ ! -z $behave_args ] && subject_errors=`echo $subject_errors,"wrong number of score files found"`
	measure_output=$measure_filler
	else
	measure_output=""
	for behavioral_measure in $behavioral_args
	do
		measure_name=`echo $behavioral_measure | cut -d "," -f 1`
		measure_min=`echo $behavioral_measure | cut -d "," -f 2`
		measure_value=`grep $measure_name $behave | cut -f 3`
		[ -z "$measure_value" ] && subject_errors=`echo $subject_errors,"missing behavioral measure"` && break
		measure_output=`echo $measure_output,$measure_value,$measure_min`	
	done
	measure_output=`echo $measure_output | sed s/^,//`
	fi

	###check that processed data exists
	data=`ls /import/monstrum/$protocol/subjects/$bblid"_"$scanid/$file_path 2> /dev/null`
	if [ "X$data" == "X" ];then
		echo $bblid,$scanid,$USER,$HOSTNAME,$0,0,1,$meanrel,$maxrel,$meantsnr,,,,$measure_output
		subject_errors=`echo $subject_errors,"/import/monstrum/$protocol/subjects/$bblid"_"$scanid/$file_path not found"`
		echo $bblid,$scanid,$USER,$HOSTNAME,$0,0,1,$meanrel,$maxrel,$meantsnr,,,,$measure_output >> $out_path
	elif [ `echo $data | wc -w` -gt 1 ];then
		echo "Error - more than one sequence file found for "$bblid
		subject_errors=`echo $subject_errors,"more than one sequence file found"`
		echo $bblid,$scanid,$USER,$HOSTNAME,$0,0,1,$meanrel,$maxrel,,,,,$measure_output
		echo $bblid,$scanid,$USER,$HOSTNAME,$0,0,1,$meanrel,$maxrel,,,,,$measure_output >> $out_path
	else
		found_data=1
		data_dir=`dirname $data`
	fi
	
	if [ $found_data == 1 ];then
	###check coverage
	coverage=`/import/speedy/scripts/hopsonr/QA/check_coverage_QA_v3.sh -f $data -m $mask_path`
	#echo $coverage

	###check registration with fslcc
	registration=`/import/speedy/scripts/hopsonr/QA/check_registration_QA_v2.sh -f $data`
	#echo $registration
	
	
###remember, $coverage contains TWO values
	echo $bblid,$scanid,$USER,$HOSTNAME,$0,0,0,$meanrel,$maxrel,$meantsnr,$coverage,$registration,$measure_output
	echo $bblid,$scanid,$USER,$HOSTNAME,$0,0,0,$meanrel,$maxrel,$meantsnr,$coverage,$registration,$measure_output >> $out_path
	fi # if [ $found_data == 1 ];then

	###echo subject errors
	[ "$subject_errors" != "$bblid,$scanid" ] && echo $subject_errors >> $error_path
done

error_log_test=`ls $error_path 2> /dev/null`
if [ "X$error_log_test" != "X" ] && [ ! -z $email ];then
	echo ""
	echo "Emailing error log"
	mail -s "$sequence_name QA for $protocol" $email < $error_path
fi

###run R program to create graphs and calculate exclusions
out_dir=`dirname $out_path`
r_out_path=$out_dir/qa_data_R.csv
visual_out_path=$out_dir/qa_data_visual.csv
/import/monstrum2/Applications/R3.1.2/bin/R --file=/import/speedy/scripts/hopsonr/QA/functional/functional_QA_v1.1.R --slave --args "$out_path" "$r_out_path" "$visual_out_path" "$redcap_name" "$meanrelrms_cutoff" "$maxrelrms_cutoff" "$tsnr_cutoff"

if [ ! -z $redcap_name ];then
	/import/monstrum/Applications/R3.0.2/bin/R --file=/import/speedy/scripts/hopsonr/R_utilities/upload_to_redcap.R --slave --args "$recap_name" "$out_path"
fi

